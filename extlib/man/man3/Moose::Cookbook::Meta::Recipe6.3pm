.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Meta::Recipe6 3"
.TH Moose::Cookbook::Meta::Recipe6 3 "2011-08-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Moose::Cookbook::Meta::Recipe6 \- A method metaclass for marking methods public or private
.SH "VERSION"
.IX Header "VERSION"
version 2.0203
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::Meta::Method;
.Ve
.PP
.Vb 2
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
.Ve
.PP
.Vb 1
\&  extends 'Moose::Meta::Method';
.Ve
.PP
.Vb 6
\&  has '_policy' => (
\&      is       => 'ro',
\&      isa      => enum( [ qw( public private ) ] ),
\&      default  => 'public',
\&      init_arg => 'policy',
\&  );
.Ve
.PP
.Vb 3
\&  sub new {
\&      my $class   = shift;
\&      my %options = @_;
.Ve
.PP
.Vb 1
\&      my $self = $class->SUPER::wrap(%options);
.Ve
.PP
.Vb 1
\&      $self->{_policy} = $options{policy};
.Ve
.PP
.Vb 1
\&      $self->_add_policy_wrapper;
.Ve
.PP
.Vb 2
\&      return $self;
\&  }
.Ve
.PP
.Vb 2
\&  sub _add_policy_wrapper {
\&      my $self = shift;
.Ve
.PP
.Vb 1
\&      return if $self->is_public;
.Ve
.PP
.Vb 3
\&      my $name      = $self->name;
\&      my $package   = $self->package_name;
\&      my $real_body = $self->body;
.Ve
.PP
.Vb 3
\&      my $body = sub {
\&          die "The $package\e::$name method is private"
\&              unless ( scalar caller() ) eq $package;
.Ve
.PP
.Vb 2
\&          goto &{$real_body};
\&      };
.Ve
.PP
.Vb 2
\&      $self->{body} = $body;
\&  }
.Ve
.PP
.Vb 2
\&  sub is_public  { $_[0]->_policy eq 'public' }
\&  sub is_private { $_[0]->_policy eq 'private' }
.Ve
.PP
.Vb 1
\&  package MyApp::User;
.Ve
.PP
.Vb 1
\&  use Moose;
.Ve
.PP
.Vb 1
\&  has 'password' => ( is => 'rw' );
.Ve
.PP
.Vb 9
\&  __PACKAGE__->meta()->add_method(
\&      '_reset_password',
\&      My::Meta::Method->new(
\&          name         => '_reset_password',
\&          package_name => __PACKAGE__,
\&          body         => sub { $_[0]->password('reset') },
\&          policy       => 'private',
\&      )
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This example shows a custom method metaclass that models public versus
private methods. If a method is defined as private, it adds a wrapper
around the method which dies unless it is called from the class where
it was defined.
.PP
The way the method is added to the class is rather ugly. If we wanted
to make this a real feature, we'd probably want to add some sort of
sugar to allow us to declare private methods, but that is beyond the
scope of this recipe. See the Extending recipes for more on this
topic.
.PP
The core of our custom class is the \f(CW\*(C`policy\*(C'\fR attribute, and
\&\f(CW\*(C`_add_policy_wrapper\*(C'\fR method.
.PP
You'll note that we have to explicitly set the \f(CW\*(C`policy\*(C'\fR attribute in
our constructor:
.PP
.Vb 1
\&      $self->{_policy} = $options{policy};
.Ve
.PP
That is necessary because Moose metaclasses do not use the meta \s-1API\s0 to
create objects. Most Moose classes have a custom \*(L"inlined\*(R" constructor
for speed.
.PP
In this particular case, our parent class's constructor is the \f(CW\*(C`wrap\*(C'\fR
method. We call that to build our object, but it does not include
subclass-specific attributes.
.PP
The \f(CW\*(C`_add_policy_wrapper\*(C'\fR method is where the real work is done. If
the method is private, we construct a wrapper around the real
subroutine which checks that the caller matches the package in which
the subroutine was created.
.PP
If they don't match, it dies. If they do match, the real method is
called. We use \f(CW\*(C`goto\*(C'\fR so that the wrapper does not show up in the
call stack.
.PP
Finally, we replace the value of \f(CW\*(C`$self\->{body}\*(C'\fR. This is another
case where we have to do something a bit gross because Moose does not
use Moose for its own implementation.
.PP
When we pass this method object to the metaclass's \f(CW\*(C`add_method\*(C'\fR
method, it will take the method body and make it available in the
class.
.PP
Finally, when we retrieve these methods via the introspection \s-1API\s0, we
can call the \f(CW\*(C`is_public\*(C'\fR and \f(CW\*(C`is_private\*(C'\fR methods on them to get
more information about the method.
.SH "SUMMARY"
.IX Header "SUMMARY"
A custom method metaclass lets us add both behavior and
meta-information to methods. Unfortunately, because the Perl
interpreter does not provide easy hooks into method declaration, the
\&\s-1API\s0 we have for adding these methods is not very pretty.
.PP
That can be improved with custom Moose-like sugar, or even by using a
tool like Devel::Declare to create full-blown new keywords in Perl.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
