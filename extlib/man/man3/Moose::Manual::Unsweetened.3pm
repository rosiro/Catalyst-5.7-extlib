.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Manual::Unsweetened 3"
.TH Moose::Manual::Unsweetened 3 "2011-08-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Moose::Manual::Unsweetened \- Moose idioms in plain old Perl 5 without the sugar
.SH "VERSION"
.IX Header "VERSION"
version 2.0203
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you're trying to figure out just what the heck Moose does, and how
it saves you time, you might find it helpful to see what Moose is
\&\fIreally\fR doing for you. This document shows you the translation from
Moose sugar back to plain old Perl 5.
.SH "CLASSES AND ATTRIBUTES"
.IX Header "CLASSES AND ATTRIBUTES"
First, we define two very small classes the Moose way.
.PP
.Vb 1
\&  package Person;
.Ve
.PP
.Vb 4
\&  use DateTime;
\&  use DateTime::Format::Natural;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
.Ve
.PP
.Vb 5
\&  has name => (
\&      is       => 'rw',
\&      isa      => 'Str',
\&      required => 1,
\&  );
.Ve
.PP
.Vb 2
\&  # Moose doesn't know about non-Moose-based classes.
\&  class_type 'DateTime';
.Ve
.PP
.Vb 4
\&  my $en_parser = DateTime::Format::Natural->new(
\&      lang      => 'en',
\&      time_zone => 'UTC',
\&  );
.Ve
.PP
.Vb 3
\&  coerce 'DateTime'
\&      => from 'Str'
\&      => via { $en_parser->parse_datetime($_) };
.Ve
.PP
.Vb 6
\&  has birth_date => (
\&      is      => 'rw',
\&      isa     => 'DateTime',
\&      coerce  => 1,
\&      handles => { birth_year => 'year' },
\&  );
.Ve
.PP
.Vb 1
\&  enum 'ShirtSize' => qw( s m l xl xxl );
.Ve
.PP
.Vb 5
\&  has shirt_size => (
\&      is      => 'rw',
\&      isa     => 'ShirtSize',
\&      default => 'l',
\&  );
.Ve
.PP
This is a fairly simple class with three attributes. We also define an enum
type to validate t\-shirt sizes because we don't want to end up with something
like \*(L"blue\*(R" for the shirt size!
.PP
.Vb 1
\&  package User;
.Ve
.PP
.Vb 3
\&  use Email::Valid;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
.Ve
.PP
.Vb 1
\&  extends 'Person';
.Ve
.PP
.Vb 4
\&  subtype 'Email'
\&      => as 'Str'
\&      => where { Email::Valid->address($_) }
\&      => message { "$_ is not a valid email address" };
.Ve
.PP
.Vb 5
\&  has email_address => (
\&      is       => 'rw',
\&      isa      => 'Email',
\&      required => 1,
\&  );
.Ve
.PP
This class subclasses Person to add a single attribute, email address.
.PP
Now we will show what these classes would look like in plain old Perl
5. For the sake of argument, we won't use any base classes or any
helpers like \f(CW\*(C`Class::Accessor\*(C'\fR.
.PP
.Vb 1
\&  package Person;
.Ve
.PP
.Vb 2
\&  use strict;
\&  use warnings;
.Ve
.PP
.Vb 3
\&  use Carp qw( confess );
\&  use DateTime;
\&  use DateTime::Format::Natural;
.Ve
.PP
.Vb 3
\&  sub new {
\&      my $class = shift;
\&      my %p = ref $_[0] ? %{ $_[0] } : @_;
.Ve
.PP
.Vb 3
\&      exists $p{name}
\&          or confess 'name is a required attribute';
\&      $class->_validate_name( $p{name} );
.Ve
.PP
.Vb 2
\&      exists $p{birth_date}
\&          or confess 'birth_date is a required attribute';
.Ve
.PP
.Vb 2
\&      $p{birth_date} = $class->_coerce_birth_date( $p{birth_date} );
\&      $class->_validate_birth_date( $p{birth_date} );
.Ve
.PP
.Vb 2
\&      $p{shirt_size} = 'l'
\&          unless exists $p{shirt_size}:
.Ve
.PP
.Vb 1
\&      $class->_validate_shirt_size( $p{shirt_size} );
.Ve
.PP
.Vb 2
\&      return bless \e%p, $class;
\&  }
.Ve
.PP
.Vb 3
\&  sub _validate_name {
\&      shift;
\&      my $name = shift;
.Ve
.PP
.Vb 1
\&      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
.Ve
.PP
.Vb 3
\&      defined $name
\&          or confess 'name must be a string';
\&  }
.Ve
.PP
.Vb 5
\&  {
\&      my $en_parser = DateTime::Format::Natural->new(
\&          lang      => 'en',
\&          time_zone => 'UTC',
\&      );
.Ve
.PP
.Vb 3
\&      sub _coerce_birth_date {
\&          shift;
\&          my $date = shift;
.Ve
.PP
.Vb 1
\&          return $date unless defined $date && ! ref $date;
.Ve
.PP
.Vb 1
\&          my $dt = $en_parser->parse_datetime($date);
.Ve
.PP
.Vb 3
\&          return $dt ? $dt : undef;
\&      }
\&  }
.Ve
.PP
.Vb 3
\&  sub _validate_birth_date {
\&      shift;
\&      my $birth_date = shift;
.Ve
.PP
.Vb 1
\&      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
.Ve
.PP
.Vb 3
\&      $birth_date->isa('DateTime')
\&          or confess 'birth_date must be a DateTime object';
\&  }
.Ve
.PP
.Vb 3
\&  sub _validate_shirt_size {
\&      shift;
\&      my $shirt_size = shift;
.Ve
.PP
.Vb 1
\&      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
.Ve
.PP
.Vb 2
\&      defined $shirt_size
\&          or confess 'shirt_size cannot be undef';
.Ve
.PP
.Vb 1
\&      my %sizes = map { $_ => 1 } qw( s m l xl xxl );
.Ve
.PP
.Vb 3
\&      $sizes{$shirt_size}
\&          or confess "$shirt_size is not a valid shirt size (s, m, l, xl, xxl)";
\&  }
.Ve
.PP
.Vb 2
\&  sub name {
\&      my $self = shift;
.Ve
.PP
.Vb 4
\&      if (@_) {
\&          $self->_validate_name( $_[0] );
\&          $self->{name} = $_[0];
\&      }
.Ve
.PP
.Vb 2
\&      return $self->{name};
\&  }
.Ve
.PP
.Vb 2
\&  sub birth_date {
\&      my $self = shift;
.Ve
.PP
.Vb 3
\&      if (@_) {
\&          my $date = $self->_coerce_birth_date( $_[0] );
\&          $self->_validate_birth_date( $date );
.Ve
.PP
.Vb 2
\&          $self->{birth_date} = $date;
\&      }
.Ve
.PP
.Vb 2
\&      return $self->{birth_date};
\&  }
.Ve
.PP
.Vb 2
\&  sub birth_year {
\&      my $self = shift;
.Ve
.PP
.Vb 2
\&      return $self->birth_date->year;
\&  }
.Ve
.PP
.Vb 2
\&  sub shirt_size {
\&      my $self = shift;
.Ve
.PP
.Vb 4
\&      if (@_) {
\&          $self->_validate_shirt_size( $_[0] );
\&          $self->{shirt_size} = $_[0];
\&      }
.Ve
.PP
.Vb 2
\&      return $self->{shirt_size};
\&  }
.Ve
.PP
Wow, that was a mouthful! One thing to note is just how much space the
data validation code consumes. As a result, it's pretty common for
Perl 5 programmers to just not bother. Unfortunately, not validating
arguments leads to surprises down the line (\*(L"why is birth_date an
email address?\*(R").
.PP
Also, did you spot the (intentional) bug?
.PP
It's in the \f(CW\*(C`_validate_birth_date()\*(C'\fR method. We should check that
the value in \f(CW$birth_date\fR is actually defined and an object before
we go and call \f(CW\*(C`isa()\*(C'\fR on it! Leaving out those checks means our data
validation code could actually cause our program to die. Oops.
.PP
Note that if we add a superclass to Person we'll have to change the
constructor to account for that.
.PP
(As an aside, getting all the little details of what Moose does for
you just right in this example was really not easy, which emphasizes
the point of the example. Moose saves you a lot of work!)
.PP
Now let's see User:
.PP
.Vb 1
\&  package User;
.Ve
.PP
.Vb 2
\&  use strict;
\&  use warnings;
.Ve
.PP
.Vb 3
\&  use Carp qw( confess );
\&  use Email::Valid;
\&  use Scalar::Util qw( blessed );
.Ve
.PP
.Vb 1
\&  use base 'Person';
.Ve
.PP
.Vb 3
\&  sub new {
\&      my $class = shift;
\&      my %p = ref $_[0] ? %{ $_[0] } : @_;
.Ve
.PP
.Vb 3
\&      exists $p{email_address}
\&          or confess 'email_address is a required attribute';
\&      $class->_validate_email_address( $p{email_address} );
.Ve
.PP
.Vb 1
\&      my $self = $class->SUPER::new(%p);
.Ve
.PP
.Vb 1
\&      $self->{email_address} = $p{email_address};
.Ve
.PP
.Vb 2
\&      return $self;
\&  }
.Ve
.PP
.Vb 3
\&  sub _validate_email_address {
\&      shift;
\&      my $email_address = shift;
.Ve
.PP
.Vb 1
\&      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
.Ve
.PP
.Vb 2
\&      defined $email_address
\&          or confess 'email_address must be a string';
.Ve
.PP
.Vb 3
\&      Email::Valid->address($email_address)
\&          or confess "$email_address is not a valid email address";
\&  }
.Ve
.PP
.Vb 2
\&  sub email_address {
\&      my $self = shift;
.Ve
.PP
.Vb 4
\&      if (@_) {
\&          $self->_validate_email_address( $_[0] );
\&          $self->{email_address} = $_[0];
\&      }
.Ve
.PP
.Vb 2
\&      return $self->{email_address};
\&  }
.Ve
.PP
That one was shorter, but it only has one attribute.
.PP
Between the two classes, we have a whole lot of code that doesn't do
much. We could probably simplify this by defining some sort of
\&\*(L"attribute and validation\*(R" hash, like this:
.PP
.Vb 1
\&  package Person;
.Ve
.PP
.Vb 14
\&  my %Attr = (
\&      name => {
\&          required => 1,
\&          validate => sub { defined $_ },
\&      },
\&      birth_date => {
\&          required => 1,
\&          validate => sub { blessed $_ && $_->isa('DateTime') },
\&      },
\&      shirt_size => {
\&          required => 1,
\&          validate => sub { defined $_ && $_ =~ /^(?:s|m|l|xl|xxl)$/i },
\&      }
\&  );
.Ve
.PP
Then we could define a base class that would accept such a definition,
and do the right thing. Keep that sort of thing up and we're well on
our way to writing a half-assed version of Moose!
.PP
Of course, there are \s-1CPAN\s0 modules that do some of what Moose does,
like \f(CW\*(C`Class::Accessor\*(C'\fR, \f(CW\*(C`Class::Meta\*(C'\fR, and so on. But none of them
put together all of Moose's features along with a layer of declarative
sugar, nor are these other modules designed for extensibility in the
same way as Moose. With Moose, it's easy to write a MooseX module to
replace or extend a piece of built-in functionality.
.PP
Moose is a complete \s-1OO\s0 package in and of itself, and is part of a rich
ecosystem of extensions. It also has an enthusiastic community of
users, and is being actively maintained and developed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
