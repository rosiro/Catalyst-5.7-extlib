.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Meta::TypeConstraint 3"
.TH Moose::Meta::TypeConstraint 3 "2011-08-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Moose::Meta::TypeConstraint \- The Moose Type Constraint metaclass
.SH "VERSION"
.IX Header "VERSION"
version 2.0203
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class represents a single type constraint. Moose's built-in type
constraints, as well as constraints you define, are all stored in a
Moose::Meta::TypeConstraint::Registry object as objects of this
class.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`Moose::Meta::TypeConstraint\*(C'\fR is a subclass of Class::MOP::Object.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBMoose::Meta::TypeConstraint\->new(%options)\fR" 4
.IX Item "Moose::Meta::TypeConstraint->new(%options)"
This creates a new type constraint based on the provided \f(CW%options\fR:
.RS 4
.IP "* name" 8
.IX Item "name"
The constraint name. If a name is not provided, it will be set to
\&\*(L"_\|_ANON_\|_\*(R".
.IP "* parent" 8
.IX Item "parent"
A \f(CW\*(C`Moose::Meta::TypeConstraint\*(C'\fR object which is the parent type for
the type being created. This is optional.
.IP "* constraint" 8
.IX Item "constraint"
This is the subroutine reference that implements the actual constraint
check. This defaults to a subroutine which always returns true.
.IP "* message" 8
.IX Item "message"
A subroutine reference which is used to generate an error message when
the constraint fails. This is optional.
.IP "* coercion" 8
.IX Item "coercion"
A Moose::Meta::TypeCoercion object representing the coercions to
the type. This is optional.
.IP "* inlined" 8
.IX Item "inlined"
A subroutine which returns a string suitable for inlining this type
constraint. It will be called as a method on the type constraint object, and
will receive a single additional parameter, a variable name to be tested
(usually \f(CW"$_"\fR or \f(CW"$_[0]"\fR.
.Sp
This is optional.
.IP "* inline_environment" 8
.IX Item "inline_environment"
A hash reference of variables to close over. The keys are variables names, and
the values are \fIreferences\fR to the variables.
.IP "* optimized" 8
.IX Item "optimized"
\&\fBThis option is deprecated.\fR
.Sp
This is a variant of the \f(CW\*(C`constraint\*(C'\fR parameter that is somehow
optimized. Typically, this means incorporating both the type's
constraint and all of its parents' constraints into a single
subroutine reference.
.RE
.RS 4
.RE
.IP "\fB$constraint\->equals($type_name_or_object)\fR" 4
.IX Item "$constraint->equals($type_name_or_object)"
Returns true if the supplied name or type object is the same as the
current type.
.IP "\fB$constraint\->is_subtype_of($type_name_or_object)\fR" 4
.IX Item "$constraint->is_subtype_of($type_name_or_object)"
Returns true if the supplied name or type object is a parent of the
current type.
.IP "\fB$constraint\->is_a_type_of($type_name_or_object)\fR" 4
.IX Item "$constraint->is_a_type_of($type_name_or_object)"
Returns true if the given type is the same as the current type, or is
a parent of the current type. This is a shortcut for checking
\&\f(CW\*(C`equals\*(C'\fR and \f(CW\*(C`is_subtype_of\*(C'\fR.
.IP "\fB$constraint\->coerce($value)\fR" 4
.IX Item "$constraint->coerce($value)"
This will attempt to coerce the value to the type. If the type does not
have any defined coercions this will throw an error.
.Sp
If no coercion can produce a value matching \f(CW$constraint\fR, the original
value is returned.
.IP "\fB$constraint\->assert_coerce($value)\fR" 4
.IX Item "$constraint->assert_coerce($value)"
This method behaves just like \f(CW\*(C`coerce\*(C'\fR, but if the result is not valid
according to \f(CW$constraint\fR, an error is thrown.
.IP "\fB$constraint\->check($value)\fR" 4
.IX Item "$constraint->check($value)"
Returns true if the given value passes the constraint for the type.
.IP "\fB$constraint\->validate($value)\fR" 4
.IX Item "$constraint->validate($value)"
This is similar to \f(CW\*(C`check\*(C'\fR. However, if the type \fIis valid\fR then the
method returns an explicit \f(CW\*(C`undef\*(C'\fR. If the type is not valid, we call
\&\f(CW\*(C`$self\->get_message($value)\*(C'\fR internally to generate an error
message.
.IP "\fB$constraint\->assert_valid($value)\fR" 4
.IX Item "$constraint->assert_valid($value)"
Like \f(CW\*(C`check\*(C'\fR and \f(CW\*(C`validate\*(C'\fR, this method checks whether \f(CW$value\fR is
valid under the constraint.  If it is, it will return true.  If it is not,
an exception will be thrown with the results of
\&\f(CW\*(C`$self\->get_message($value)\*(C'\fR.
.IP "\fB$constraint\->name\fR" 4
.IX Item "$constraint->name"
Returns the type's name, as provided to the constructor.
.IP "\fB$constraint\->parent\fR" 4
.IX Item "$constraint->parent"
Returns the type's parent, as provided to the constructor, if any.
.IP "\fB$constraint\->has_parent\fR" 4
.IX Item "$constraint->has_parent"
Returns true if the type has a parent type.
.IP "\fB$constraint\->parents\fR" 4
.IX Item "$constraint->parents"
A synonym for \f(CW\*(C`parent\*(C'\fR. This is useful for polymorphism with types
that can have more than one parent.
.IP "\fB$constraint\->constraint\fR" 4
.IX Item "$constraint->constraint"
Returns the type's constraint, as provided to the constructor.
.IP "\fB$constraint\->get_message($value)\fR" 4
.IX Item "$constraint->get_message($value)"
This generates a method for the given value. If the type does not have
an explicit message, we generate a default message.
.IP "\fB$constraint\->has_message\fR" 4
.IX Item "$constraint->has_message"
Returns true if the type has a message.
.IP "\fB$constraint\->message\fR" 4
.IX Item "$constraint->message"
Returns the type's message as a subroutine reference.
.IP "\fB$constraint\->coercion\fR" 4
.IX Item "$constraint->coercion"
Returns the type's Moose::Meta::TypeCoercion object, if one
exists.
.IP "\fB$constraint\->has_coercion\fR" 4
.IX Item "$constraint->has_coercion"
Returns true if the type has a coercion.
.IP "\fB$constraint\->can_be_inlined\fR" 4
.IX Item "$constraint->can_be_inlined"
Returns true if this type constraint can be inlined. A type constraint which
subtypes an inlinable constraint and does not add an additional constraint
\&\*(L"inherits\*(R" its parent type's inlining.
.IP "\fB$constraint\->hand_optimized_type_constraint\fR" 4
.IX Item "$constraint->hand_optimized_type_constraint"
\&\fBThis method is deprecated.\fR
.Sp
Returns the type's hand optimized constraint, as provided to the
constructor via the \f(CW\*(C`optimized\*(C'\fR option.
.IP "\fB$constraint\->has_hand_optimized_type_constraint\fR" 4
.IX Item "$constraint->has_hand_optimized_type_constraint"
\&\fBThis method is deprecated.\fR
.Sp
Returns true if the type has an optimized constraint.
.IP "\fB$constraint\->create_child_type(%options)\fR" 4
.IX Item "$constraint->create_child_type(%options)"
This returns a new type constraint of the same class using the
provided \f(CW%options\fR. The \f(CW\*(C`parent\*(C'\fR option will be the current type.
.Sp
This method exists so that subclasses of this class can override this
behavior and change how child types are created.
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\s0\*(R" in Moose for details on reporting bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
