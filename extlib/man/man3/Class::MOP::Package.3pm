.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::MOP::Package 3"
.TH Class::MOP::Package 3 "2011-08-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Class::MOP::Package \- Package Meta Object
.SH "VERSION"
.IX Header "VERSION"
version 2.0203
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Package Protocol provides an abstraction of a Perl 5 package. A
package is basically namespace, and this module provides methods for
looking at and changing that namespace's symbol table.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "\fBClass::MOP::Package\->initialize($package_name, \fB%options\fB)\fR" 4
.el .IP "\fBClass::MOP::Package\->initialize($package_name, \f(CB%options\fB)\fR" 4
.IX Item "Class::MOP::Package->initialize($package_name, %options)"
This method creates a new \f(CW\*(C`Class::MOP::Package\*(C'\fR instance which
represents specified package. If an existing metaclass object exists
for the package, that will be returned instead. No options are valid at the
package level.
.ie n .IP "\fBClass::MOP::Package\->reinitialize($package, \fB%options\fB)\fR" 4
.el .IP "\fBClass::MOP::Package\->reinitialize($package, \f(CB%options\fB)\fR" 4
.IX Item "Class::MOP::Package->reinitialize($package, %options)"
This method forcibly removes any existing metaclass for the package
before calling \f(CW\*(C`initialize\*(C'\fR. In contrast to \f(CW\*(C`initialize\*(C'\fR, you may
also pass an existing \f(CW\*(C`Class::MOP::Package\*(C'\fR instance instead of just
a package name as \f(CW$package\fR.
.Sp
Do not call this unless you know what you are doing.
.ie n .IP "\fBClass::MOP::Package\->create($package, \fB%options\fB)\fR" 4
.el .IP "\fBClass::MOP::Package\->create($package, \f(CB%options\fB)\fR" 4
.IX Item "Class::MOP::Package->create($package, %options)"
Creates a new \f(CW\*(C`Class::MOP::Package\*(C'\fR instance which represents the specified
package, and also does some initialization of that package. Currently, this
just does the same thing as \f(CW\*(C`initialize\*(C'\fR, but is overridden in subclasses,
such as \f(CW\*(C`Class::MOP::Class\*(C'\fR.
.IP "\fBClass::MOP::Package\->create_anon(%options)\fR" 4
.IX Item "Class::MOP::Package->create_anon(%options)"
Creates a new anonymous package. Valid keys for \f(CW%options\fR are:
.RS 4
.ie n .IP """weaken""" 4
.el .IP "\f(CWweaken\fR" 4
.IX Item "weaken"
If this is true (the default), the instance stored in \f(CW\*(C`Class::MOP\*(C'\fR's metaclass
cache will be weakened, so that the anonymous package will be garbage collected
when the returned instance goes out of scope.
.RE
.RS 4
.RE
.IP "\fB$metapackage\->is_anon\fR" 4
.IX Item "$metapackage->is_anon"
Returns true if the package is an anonymous package.
.IP "\fB$metapackage\->name\fR" 4
.IX Item "$metapackage->name"
This is returns the package's name, as passed to the constructor.
.IP "\fB$metapackage\->namespace\fR" 4
.IX Item "$metapackage->namespace"
This returns a hash reference to the package's symbol table. The keys
are symbol names and the values are typeglob references.
.ie n .IP "\fB$metapackage\->add_package_symbol($variable_name, \fB$initial_value\fB)\fR" 4
.el .IP "\fB$metapackage\->add_package_symbol($variable_name, \f(CB$initial_value\fB)\fR" 4
.IX Item "$metapackage->add_package_symbol($variable_name, $initial_value)"
This method accepts a variable name and an optional initial value. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.Sp
This method creates the variable in the package's symbol table, and
sets it to the initial value if one was provided.
.IP "\fB$metapackage\->get_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->get_package_symbol($variable_name)"
Given a variable name, this method returns the variable as a reference
or undef if it does not exist. The \f(CW$variable_name\fR must contain a
leading sigil.
.IP "\fB$metapackage\->get_or_add_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->get_or_add_package_symbol($variable_name)"
Given a variable name, this method returns the variable as a reference.
If it does not exist, a default value will be generated if possible. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.IP "\fB$metapackage\->has_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->has_package_symbol($variable_name)"
Returns true if there is a package variable defined for
\&\f(CW$variable_name\fR. The \f(CW$variable_name\fR must contain a leading sigil.
.IP "\fB$metapackage\->remove_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->remove_package_symbol($variable_name)"
This will remove the package variable specified \f(CW$variable_name\fR. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.IP "\fB$metapackage\->remove_package_glob($glob_name)\fR" 4
.IX Item "$metapackage->remove_package_glob($glob_name)"
Given the name of a glob, this will remove that glob from the
package's symbol table. Glob names do not include a sigil. Removing
the glob removes all variables and subroutines with the specified
name.
.IP "\fB$metapackage\->list_all_package_symbols($type_filter)\fR" 4
.IX Item "$metapackage->list_all_package_symbols($type_filter)"
This will list all the glob names associated with the current
package. These names do not have leading sigils.
.Sp
You can provide an optional type filter, which should be one of
\&'\s-1SCALAR\s0', '\s-1ARRAY\s0', '\s-1HASH\s0', or '\s-1CODE\s0'.
.IP "\fB$metapackage\->get_all_package_symbols($type_filter)\fR" 4
.IX Item "$metapackage->get_all_package_symbols($type_filter)"
This works much like \f(CW\*(C`list_all_package_symbols\*(C'\fR, but it returns a
hash reference. The keys are glob names and the values are references
to the value for that name.
.IP "\fBClass::MOP::Package\->meta\fR" 4
.IX Item "Class::MOP::Package->meta"
This will return a Class::MOP::Class instance for this class.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
